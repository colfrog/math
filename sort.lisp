(in-package :clf-math)

(defun insertion-sort (a &optional start-index end-index)
  (let ((start (if start-index start-index 0))
	(end (if end-index end-index (length a))))
    (do ((i (1+ start) (1+ i)))
	((= i end) a)
      (let ((temp (aref a i)))
	(do ((j i (1- j)))
	    ((or (= j start) (< (aref a (1- j)) temp))
	     (setf (aref a j) temp))
	  (setf (aref a j) (aref a (1- j))))))))

(defun merge-array (a b start-left end-left start-right end-right)
  (let ((left-index start-left)
	(right-index start-right)
	(write-index start-left))
    (do () ((or (> left-index end-left) (> right-index end-right)) nil)
      (if (<= (aref a left-index) (aref a right-index))
	  (progn
	    (setf (aref b write-index) (aref a left-index))
	    (setf left-index (1+ left-index)))
	  (progn
	    (setf (aref b write-index) (aref a right-index))
	    (setf right-index (1+ right-index))))
      (setf write-index (1+ write-index)))

    (do ((i left-index (1+ i)))
	((> i end-left) nil)
      (setf (aref b write-index) (aref a i))
      (setf write-index (1+ write-index)))

    (do ((i right-index (1+ i)))
	((> i end-right) nil)
      (setf (aref b write-index) (aref a i))
      (setf write-index (1+ write-index)))

    (do ((index start-left (1+ index)))
	((> index end-right) a)
      (setf (aref a index) (aref b index)))))

(defun merge-sort-rec (a b start end)
  (when (< start end)
    (let* ((start-left start)
	   (end-left (floor (/ (+ start end) 2)))
	   (start-right (1+ end-left))
	   (end-right end))
      (merge-sort-rec a b start-left end-left)
      (merge-sort-rec a b start-right end-right)
      (merge-array a b start-left end-left start-right end-right))))

(defun merge-sort (a &optional start-index end-index)
  (let ((b (make-array (length a)))
	(start (if start-index start-index 0))
	(end (if end-index (1- end-index) (1- (length a)))))
    (dotimes (i (length a))
      (setf (aref b i) (aref a i)))
    (merge-sort-rec a b start end)))

(defun radix-sort (a &key start-index end-index (digits 3) (base 10))
  (let ((start (if start-index start-index 0))
	(end (if end-index (1- end-index) (1- (length a))))
	(q1 (make-array base))
	(q2 (make-array base))
	(switch t))
    (dotimes (i base)
      (setf (aref q1 i) (make-instance 'queue))
      (setf (aref q2 i) (make-instance 'queue)))
    (do* ((index start (1+ index)))
	 ((> index end) nil)
      (let ((value (aref a index)))
	(push-queue (aref q1 (mod value base)) value)))
    (setf switch (not switch))
    (dotimes (i (1- digits))
      (let ((last-q (if (not switch) q1 q2)))
	(dotimes (j base)
	  (do ((value (pop-queue (aref last-q j))
		      (pop-queue (aref last-q j))))
	      ((null value) nil)
	    (let* ((new-base (expt base (1+ i)))
		   (floor-val (floor (/ value new-base))))
	      (push-queue (aref (if switch q1 q2) (mod floor-val base)) value))))
	(setf switch (not switch))))
    (let ((i 0))
      (dotimes (j base)
	(do ((value (pop-queue (aref (if (not switch) q1 q2) j))
		    (pop-queue (aref (if (not switch) q1 q2) j))))
	    ((null value) nil)
	  (setf (aref a i) value)
	  (setf i (1+ i))))))
  a)

(defun heap-sort-in-place (a)
  (labels ((perc-down (a index size)
	     (when (< index size)
	       (let ((child (1+ (* 2 index))))
		 (when (< child size)
		   (when (and (< child (1- size))
			      (< (aref a child) (aref a (1+ child))))
		     (setf child (1+ child)))
		   (when (< (aref a index) (aref a child))
		     (let ((current-val (aref a index)))
		       (setf (aref a index) (aref a child))
		       (setf (aref a child) current-val)))
		   (perc-down a child size)))))
	   (heapify (a)
	     (do ((i (1- (length a)) (1- i)))
		 ((< i 0) a)
	       (perc-down a i (length a)))))
    (when (> (length a) 1)
      (heapify a)
      (do ((i (1- (length a)) (1- i)))
	  ((< i 0) a)
	(let ((value (aref a 0)))
	  (setf (aref a 0) (aref a i))
	  (setf (aref a i) value))
	(perc-down a 0 i)))))

(defun partition (a start end)
  (let* ((s (+ start (random (1+ (- end start)))))
	 (p (aref a s))
	 (j start))
    (setf (aref a s) (aref a start))
    (setf (aref a start) p)
    (do ((i (1+ start) (1+ i)))
	((> i end) nil)
      (when (< (aref a i) p)
	(setf j (1+ j))
	(let ((temp (aref a j)))
	  (setf (aref a j) (aref a i))
	  (setf (aref a i) temp))))
    (setf (aref a start) (aref a j))
    (setf (aref a j) p)
    j))

(defun quicksort-rec (a start end)
  (when (> end start)
    (let ((s (partition a start end)))
      (quicksort-rec a start s)
      (quicksort-rec a (1+ s) end))))

(defun quicksort (a &key (start-index 0) (end-index 0))
  (let ((start start-index)
	(end (1- (if (= end-index 0) (length a) end-index))))
    (quicksort-rec a start end)))
