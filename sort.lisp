(in-package :clf-math)

(defun insertion-sort (a &optional start-index end-index)
  (let ((start (if start-index start-index 0))
	(end (if end-index end-index (length a))))
    (do ((i (1+ start) (1+ i)))
	((= i end) a)
      (let ((temp (aref a i)))
	(do ((j i (1- j)))
	    ((or (= j start) (< (aref a (1- j)) temp))
	     (setf (aref a j) temp))
	  (setf (aref a j) (aref a (1- j))))))))

(defun merge-array (a b start-left end-left start-right end-right)
  (let ((left-index start-left)
	(right-index start-right)
	(write-index start-left))
    (do () ((or (> left-index end-left) (> right-index end-right)) nil)
      (if (<= (aref a left-index) (aref a right-index))
	  (progn
	    (setf (aref b write-index) (aref a left-index))
	    (setf left-index (1+ left-index)))
	  (progn
	    (setf (aref b write-index) (aref a right-index))
	    (setf right-index (1+ right-index))))
      (setf write-index (1+ write-index)))

    (do ((i left-index (1+ i)))
	((> i end-left) nil)
      (setf (aref b write-index) (aref a i))
      (setf write-index (1+ write-index)))

    (do ((i right-index (1+ i)))
	((> i end-right) nil)
      (setf (aref b write-index) (aref a i))
      (setf write-index (1+ write-index)))

    (do ((index start-left (1+ index)))
	((> index end-right) a)
      (setf (aref a index) (aref b index)))))

(defun merge-sort-rec (a b start end)
  (when (< start end)
    (let* ((start-left start)
	   (end-left (floor (/ (+ start end) 2)))
	   (start-right (1+ end-left))
	   (end-right end))
      (merge-sort-rec a b start-left end-left)
      (merge-sort-rec a b start-right end-right)
      (merge-array a b start-left end-left start-right end-right))))

(defun merge-sort (a &optional start-index end-index)
  (let ((b (make-array (length a)))
	(start (if start-index start-index 0))
	(end (if end-index (1- end-index) (1- (length a)))))
    (dotimes (i (length a))
      (setf (aref b i) (aref a i)))
    (merge-sort-rec a b start end)))
