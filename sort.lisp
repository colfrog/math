(in-package :clf-math)

(defun insertion-sort (a &optional start-index end-index)
  (let ((start (if start-index start-index 0))
	(end (if end-index end-index (length a))))
    (do ((i (1+ start) (1+ i)))
	((= i end) a)
      (let ((temp (aref a i)))
	(do ((j i (1- j)))
	    ((or (= j start) (< (aref a (1- j)) temp))
	     (setf (aref a j) temp))
	  (setf (aref a j) (aref a (1- j))))))))

(defun merge-array (a b start-left end-left start-right end-right)
  (let ((left-index start-left)
	(right-index start-right)
	(write-index start-left))
    (do () ((or (> left-index end-left) (> right-index end-right)) nil)
      (if (<= (aref a left-index) (aref a right-index))
	  (progn
	    (setf (aref b write-index) (aref a left-index))
	    (setf left-index (1+ left-index)))
	  (progn
	    (setf (aref b write-index) (aref a right-index))
	    (setf right-index (1+ right-index))))
      (setf write-index (1+ write-index)))

    (do ((i left-index (1+ i)))
	((> i end-left) nil)
      (setf (aref b write-index) (aref a i))
      (setf write-index (1+ write-index)))

    (do ((i right-index (1+ i)))
	((> i end-right) nil)
      (setf (aref b write-index) (aref a i))
      (setf write-index (1+ write-index)))

    (do ((index start-left (1+ index)))
	((> index end-right) a)
      (setf (aref a index) (aref b index)))))

(defun merge-sort-rec (a b start end)
  (when (< start end)
    (let* ((start-left start)
	   (end-left (floor (/ (+ start end) 2)))
	   (start-right (1+ end-left))
	   (end-right end))
      (merge-sort-rec a b start-left end-left)
      (merge-sort-rec a b start-right end-right)
      (merge-array a b start-left end-left start-right end-right))))

(defun merge-sort (a &optional start-index end-index)
  (let ((b (make-array (length a)))
	(start (if start-index start-index 0))
	(end (if end-index (1- end-index) (1- (length a)))))
    (dotimes (i (length a))
      (setf (aref b i) (aref a i)))
    (merge-sort-rec a b start end)))

(defun radix-sort (a &key start-index end-index (digits 3) (base 10))
  (let ((start (if start-index start-index 0))
	(end (if end-index (1- end-index) (1- (length a))))
	(q1 (make-array base))
	(q2 (make-array base))
	(switch t))
    (dotimes (i base)
      (setf (aref q1 i) (make-instance 'queue))
      (setf (aref q2 i) (make-instance 'queue)))
    (do* ((index start (1+ index)))
	 ((> index end) nil)
      (let ((value (aref a index)))
	(push-queue (aref q1 (mod value base)) value)))
    (setf switch (not switch))
    (dotimes (i (1- digits))
      (let ((last-q (if (not switch) q1 q2)))
	(dotimes (j base)
	  (do ((value (pop-queue (aref last-q j))
		      (pop-queue (aref last-q j))))
	      ((null value) nil)
	    (let* ((new-base (expt base (1+ i)))
		   (floor-val (floor (/ value new-base))))
	      (push-queue (aref (if switch q1 q2) (mod floor-val base)) value))))
	(setf switch (not switch))))
    (let ((i 0))
      (dotimes (j base)
	(do ((value (pop-queue (aref (if (not switch) q1 q2) j))
		    (pop-queue (aref (if (not switch) q1 q2) j))))
	    ((null value) nil)
	  (setf (aref a i) value)
	  (setf i (1+ i))))))
  a)
