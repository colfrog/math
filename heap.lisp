(in-package :clf-math)

(defclass heap ()
  ((data :initform (make-instance 'dyn-array))
   (size :initform 0)
   (comparator :initform #'< :initarg :comparator)))

(defun make-heap (list)
  (let ((h (make-instance 'heap)))
    (dolist (elem list)
      (push-heap h elem))
    h))

(defmethod push-heap ((h heap) value)
  (with-slots (data size comparator) h
    (push-dyn-array data value)
    (when (> size 0)
      (do* ((child-index size parent-index)
	    (parent-index (floor (/ (1- child-index) 2))
			  (if (> child-index 0)
			      (floor (/ (1- child-index) 2))
			      0))
	    (child-value (get-dyn-array data child-index)
			 (get-dyn-array data child-index))
	    (parent-value (get-dyn-array data parent-index)
			  (get-dyn-array data parent-index)))
	   ((or (= child-index 0) (not (funcall comparator parent-value child-value)))
	    data)
	(set-dyn-array data child-index parent-value)
	(set-dyn-array data parent-index child-value)))
    (setf size (1+ size))))

(defmethod heap-sort ((h heap))
  (with-slots (data size comparator) h
    (labels ((perc-down (a index size)
	       (when (< index size)
		 (let ((child (1+ (* 2 index))))
		   (when (< child size)
		     (when (and (< child (1- size))
				(funcall comparator (aref a child) (aref a (1+ child))))
		       (setf child (1+ child)))
		     (when (funcall comparator (aref a index) (aref a child))
		       (let ((current-val (aref a index)))
			 (setf (aref a index) (aref a child))
			 (setf (aref a child) current-val)))
		     (perc-down a child size))))))
      (let ((sorted (make-array size)))
	(dotimes (i size)
	  (setf (aref sorted i) (get-dyn-array data i)))
	(do ((i (1- size) (1- i)))
	    ((= i 0) sorted)
	  (let ((current-val (aref sorted 0)))
	    (setf (aref sorted 0) (aref sorted i))
	    (setf (aref sorted i) current-val))
	  (perc-down sorted 0 i))))))

(defmethod print-object ((h heap) stream)
  (print-object (slot-value h 'data) stream))
